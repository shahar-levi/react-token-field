{"version":3,"sources":["../../src/TokensReducer/TokensReducer.tsx","../../src/Token/Token.tsx","../../src/Utils/Utils.ts","../../src/TokenInput/TokenInput.tsx","../../src/TokenNewInput/TokenNewInput.tsx","../../src/TokenField/TokenField.tsx","../../src/Styles/Token.style.ts","App.tsx","index.tsx"],"names":["Token","index","deleteToken","text","editToken","focus","getTokenStyle","isValid","deleteSelected","selected","hideRemoveButton","tokenRef","useRef","useImperativeHandle","ref","window","tabIndex","onKeyDown","event","onDoubleClick","e","editItem","onMouseDown","selectItem","className","classes","style","invalid","onClick","deleteItem","Utils","inputCaretEnd","inputRef","inputTextFullSelection","inputCaretStart","TokenInput","updateToken","parseToken","containDelimiter","spanRef","view","applyToken","onPaste","setTimeout","onInput","defaultValue","onBlur","type","visibility","initialState","tokens","selectedIndexes","editIndex","focusIndex","lastActionTime","handleFocus","state","Math","focusBack","focusNext","ActionType","reducer","updatedState","action","Date","lastIndex","multi","Array","Set","TokenNewInput","placeholder","addToken","deleteLast","selectToken","allTokenAreSelected","focusLast","updateSpanText","keyDown","viewMode","useEffect","value","clear","selectText","TokenField","cssStyle","delimiters","pattern","readonly","showRemoveButton","tokenFieldCSS","getTokenCSS","onChange","autoFocus","tokenProps","useReducer","dispatch","indexes","payload","add","focusNew","FocusNew","selectAll","token","RegExp","regex","getSelectedTokenText","tokenState","tokenCSS","useTokens","focusRefs","newTokenRef","tokenFieldRef","newTokens","rawText","sep","tokenValue","addRef","copyToken","val","selBox","document","console","details","valid","resize","height","border","gap","padding","background","color","boxShadow","borderRadius","maxHeight","cmdPressed","navigator","onFocus","focusElement","el","key","getTokenElement","getTokenInputElement","React","App","useState","setTokens","width","margin","map","name","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.2f9f0810.chunk.js","sourcesContent":["import { useReducer } from 'react'\nimport { TokenCSS } from '../Styles/Token.style'\n\nconst initialState = {\n  tokens: [] as string[],\n  selectedIndexes: [] as number[],\n  editIndex: -1,\n  focusIndex: -1,\n  lastActionTime: ''\n}\nexport type TokensState = typeof initialState\nexport type FocusMovement = 'self' | 'back' | 'next' | 'none'\nexport type TokenState = {\n  text: string\n  selected: boolean\n  invalid: boolean\n  index: number\n}\n\nexport enum ActionType {\n  Add,\n  Update,\n  Delete,\n  DeleteLast,\n  Select,\n  Edit,\n  Focus,\n  FocusNew\n}\n\nexport interface DelimiterActions {\n  containDelimiter: (key: string) => boolean\n  parseToken: (token: string) => string[]\n}\n\ntype Action =\n  | {\n      type: ActionType.Add\n      payload: { tokens: string[]; focus: FocusMovement }\n    }\n  | {\n      type: ActionType.Delete\n      payload: { indexes: number[] }\n    }\n  | {\n      type: ActionType.Select\n      payload: { indexes: number[]; add: boolean }\n    }\n  | {\n      type: ActionType.Edit\n      payload: { index: number }\n    }\n  | {\n      type: ActionType.Update\n      payload: { index: number; tokens: string[]; focus: FocusMovement }\n    }\n  | {\n      type: ActionType.Focus\n      payload: { index: number; focus: FocusMovement }\n    }\n  | {\n      type: ActionType.FocusNew\n    }\n  | { type: ActionType.DeleteLast }\n\nfunction focusBack(index: number, state: TokensState) {\n  if (index === -1) {\n    if (state.tokens.length > 0) {\n      state.focusIndex = state.tokens.length - 1\n    }\n    return\n  }\n  state.focusIndex = Math.max(0, index - 1)\n}\n\nfunction focusNext(index: number, state: TokensState) {\n  if (index === -1 || state.tokens.length === index + 1) {\n    state.focusIndex = -1\n    return\n  }\n  state.focusIndex = Math.min(state.tokens.length - 1, index + 1)\n}\n\nfunction handleFocus(\n  state: TokensState,\n  focus: FocusMovement,\n  index: number = -1\n) {\n  if (focus === 'none') {\n    state.focusIndex = -2\n  } else if (focus === 'back') {\n    focusBack(state.focusIndex, state)\n  } else if (focus === 'next') {\n    focusNext(state.focusIndex, state)\n  } else {\n    state.focusIndex = index\n  }\n}\n\nconst reducer = (state: TokensState, action: Action) => {\n  const updatedState: TokensState = { ...state }\n  let lastIndex: number\n  const tokens = [...updatedState.tokens]\n  let multi: boolean\n  switch (action.type) {\n    case ActionType.Update:\n      updatedState.selectedIndexes = []\n      tokens.splice(action.payload.index, 1, ...action.payload.tokens)\n      updatedState.lastActionTime = new Date().toISOString()\n      updatedState.tokens = tokens\n      updatedState.editIndex = -1\n      handleFocus(updatedState, action.payload.focus)\n      updatedState.selectedIndexes = [updatedState.focusIndex]\n      return updatedState\n    case ActionType.Delete:\n      lastIndex = action.payload.indexes.length - 1\n      updatedState.lastActionTime = new Date().toISOString()\n      updatedState.tokens = updatedState.tokens.filter(\n        (_, i) => !action.payload.indexes.includes(i)\n      )\n      multi = action.payload.indexes.length > 1\n      if (multi) {\n        updatedState.focusIndex = -1\n      } else if (updatedState.focusIndex !== -1) {\n        updatedState.focusIndex = Math.min(\n          action.payload.indexes[lastIndex],\n          updatedState.tokens.length - 1\n        )\n      }\n      updatedState.selectedIndexes =\n        updatedState.focusIndex !== -1 ? [updatedState.focusIndex] : []\n      updatedState.editIndex = -1\n      return updatedState\n    case ActionType.Select:\n      updatedState.lastActionTime = new Date().toISOString()\n      if (action.payload.add) {\n        updatedState.selectedIndexes = Array.from(\n          new Set([...updatedState.selectedIndexes, ...action.payload.indexes])\n        )\n      } else {\n        updatedState.selectedIndexes = action.payload.indexes\n      }\n      if (\n        action.payload.indexes.length &&\n        updatedState.tokens.length !== updatedState.selectedIndexes.length &&\n        updatedState.focusIndex !== -1\n      ) {\n        updatedState.focusIndex =\n          action.payload.indexes[action.payload.indexes.length - 1]\n      }\n      updatedState.editIndex = -1\n      return updatedState\n    case ActionType.Add:\n      updatedState.lastActionTime = new Date().toISOString()\n      updatedState.selectedIndexes = []\n      if (action.payload.tokens) {\n        updatedState.tokens = [...updatedState.tokens, ...action.payload.tokens]\n      }\n      handleFocus(updatedState, action.payload.focus)\n      updatedState.editIndex = -1\n      return updatedState\n    case ActionType.Edit:\n      updatedState.lastActionTime = new Date().toISOString()\n      updatedState.selectedIndexes = []\n      updatedState.editIndex = action.payload.index\n      updatedState.focusIndex = action.payload.index\n      return updatedState\n    case ActionType.FocusNew:\n      updatedState.lastActionTime = new Date().toISOString()\n      updatedState.selectedIndexes = []\n      updatedState.focusIndex = -1\n      return updatedState\n    case ActionType.Focus:\n      updatedState.lastActionTime = new Date().toISOString()\n      updatedState.editIndex = -1\n      handleFocus(updatedState, action.payload.focus, action.payload.index)\n      updatedState.selectedIndexes =\n        updatedState.focusIndex !== -1 ? [updatedState.focusIndex] : []\n      return updatedState\n\n    default:\n      return state\n  }\n}\n\nexport const useTokens = (\n  tokens: string[],\n  pattern: string,\n  readonly: boolean,\n  tokenCSS?: ((tokenState: TokenState) => TokenCSS) | undefined\n) => {\n  const [state, dispatch] = useReducer(reducer, { ...initialState, tokens })\n\n  function getTokenStyle(tokenState: TokenState): TokenCSS {\n    return tokenCSS ? tokenCSS(tokenState) : {}\n  }\n\n  function updateToken(index: number, tokens: string[], focus: FocusMovement) {\n    if (!readonly) {\n      dispatch({\n        type: ActionType.Update,\n        payload: { tokens, index, focus }\n      })\n    }\n  }\n\n  function selectToken(indexes: number[], add: boolean) {\n    dispatch({\n      type: ActionType.Select,\n      payload: { indexes, add }\n    })\n  }\n\n  function deleteToken(indexes: number[]) {\n    if (!readonly) {\n      dispatch({\n        type: ActionType.Delete,\n        payload: { indexes: [...indexes] }\n      })\n    }\n  }\n\n  function deleteLast() {\n    if (!readonly) {\n      dispatch({\n        type: ActionType.Delete,\n        payload: { indexes: [state.tokens.length - 1] }\n      })\n    }\n  }\n\n  function addToken(tokens: string[], focus: FocusMovement) {\n    if (!readonly) {\n      dispatch({\n        type: ActionType.Add,\n        payload: { tokens, focus }\n      })\n    }\n  }\n\n  function editToken(index: number) {\n    if (!readonly) {\n      dispatch({\n        type: ActionType.Edit,\n        payload: { index }\n      })\n    }\n  }\n\n  function focus(index: number, focus: FocusMovement) {\n    dispatch({\n      type: ActionType.Focus,\n      payload: { focus, index }\n    })\n  }\n\n  function focusNew() {\n    dispatch({\n      type: ActionType.FocusNew\n    })\n  }\n\n  function allTokenAreSelected() {\n    return state.tokens.length === state.selectedIndexes.length\n  }\n\n  function selectAll() {\n    selectToken(Array.from(state.tokens.keys()), false)\n  }\n\n  function focusLast() {\n    focus(-1, 'back')\n  }\n\n  function deleteSelected() {\n    if (!readonly) {\n      deleteToken([...state.selectedIndexes, state.focusIndex])\n    }\n  }\n\n  function isValid(token: string): boolean {\n    const regex = new RegExp(pattern)\n    return regex.test(token)\n  }\n\n  function getSelectedTokenText() {\n    return state.selectedIndexes.map((index) => state.tokens[index])\n  }\n\n  return {\n    state,\n    selectToken,\n    focus,\n    focusLast,\n    focusNew,\n    updateToken,\n    deleteToken,\n    deleteLast,\n    deleteSelected,\n    allTokenAreSelected,\n    selectAll,\n    editToken,\n    addToken,\n    isValid,\n    getSelectedTokenText,\n    getTokenStyle\n  }\n}\n\nexport type TokenProps = ReturnType<typeof useTokens>\n","import classes from './../styles.module.css'\nimport React, { CSSProperties, useImperativeHandle, useRef } from 'react'\nimport { FocusRef } from '../TokenField/TokenField'\nimport { TokenProps } from '../TokensReducer/TokensReducer'\n\nexport interface TokenAdditionalProps {\n  index: number\n  text: string\n  selected: boolean\n  hideRemoveButton: boolean\n}\n\nexport const Token = React.forwardRef<\n  FocusRef,\n  TokenAdditionalProps & TokenProps\n>(\n  (\n    {\n      index,\n      deleteToken,\n      text,\n      editToken,\n      focus,\n      getTokenStyle,\n      isValid,\n      deleteSelected,\n      selected,\n      hideRemoveButton\n    },\n    ref\n  ): React.ReactElement => {\n    const tokenRef = useRef<HTMLSpanElement>(null)\n\n    useImperativeHandle(ref, () => ({\n      focus: () => {\n        if (tokenRef.current !== window.document.activeElement) {\n          tokenRef.current!.focus()\n        }\n      }\n    }))\n\n    function getCSS(): CSSProperties {\n      return getTokenStyle({\n        text,\n        selected,\n        invalid: !isValid(text),\n        index\n      }) as CSSProperties\n    }\n\n    function KeyDown(event: React.KeyboardEvent) {\n      if (\n        index > 0 &&\n        (event.key === 'ArrowLeft' || (event.shiftKey && event.key === 'Tab'))\n      ) {\n        focus(index, 'back')\n        event.preventDefault()\n      } else if (\n        event.key === 'ArrowRight' ||\n        (!event.shiftKey && event.key === 'Tab')\n      ) {\n        focus(index, 'next')\n        event.preventDefault()\n      } else if (\n        !event.metaKey &&\n        (event.key.length === 1 || event.key === 'Enter')\n      ) {\n        editToken(index)\n        event.preventDefault()\n      } else if (event.key === ' ') {\n        event.preventDefault()\n      } else if (event.key === 'Backspace' || event.key === 'Delete') {\n        deleteSelected()\n        event.preventDefault()\n      }\n    }\n\n    function selectItem(e: React.MouseEvent) {\n      focus(index, 'self')\n      e.preventDefault()\n    }\n\n    function deleteItem(e: React.MouseEvent) {\n      if (e.ctrlKey || e.shiftKey) {\n        return\n      }\n      deleteToken([index])\n    }\n\n    function editItem(e: React.MouseEvent) {\n      if (e.ctrlKey || e.shiftKey) {\n        return\n      }\n      editToken(index)\n    }\n\n    return (\n      <span\n        tabIndex={-1}\n        onKeyDown={(e) => KeyDown(e)}\n        ref={tokenRef}\n        onDoubleClick={(e) => editItem(e)}\n        onMouseDown={(e) => selectItem(e)}\n        className={`${classes.tag} ${!isValid(text) ? classes.invalid : ''} ${\n          selected ? classes.selected : ''\n        }`}\n        style={getCSS()}\n      >\n        <span className={classes.value}>{text}</span>\n        {hideRemoveButton ? (\n          <span onClick={(e) => deleteItem(e)} className={classes.remove} />\n        ) : null}\n      </span>\n    )\n  }\n)\n","class Utils {\n  static inputCaretEnd(inputRef: HTMLInputElement | null): boolean {\n    if (!inputRef) return false\n    return (\n      inputRef.selectionStart === inputRef.value.length &&\n      inputRef.selectionEnd === inputRef.value.length\n    )\n  }\n\n  static inputTextFullSelection(inputRef: HTMLInputElement | null) {\n    if (!inputRef) return false\n    return (\n      inputRef.selectionStart === 0 &&\n      inputRef.selectionEnd === inputRef.value.length\n    )\n  }\n\n  static inputCaretStart(inputRef: HTMLInputElement | null): boolean {\n    if (!inputRef) return false\n    return inputRef.selectionStart === 0 && inputRef.selectionEnd === 0\n  }\n}\nexport default Utils\n","import classes from './../styles.module.css'\nimport React, { useImperativeHandle, useRef } from 'react'\n\nimport { FocusRef } from '../TokenField/TokenField'\nimport Utils from '../Utils/Utils'\nimport {\n  DelimiterActions,\n  FocusMovement,\n  TokenProps\n} from '../TokensReducer/TokensReducer'\n\nexport interface TokenAdditionalProps {\n  index: number\n  text: string\n  selected: boolean\n  hideRemoveButton: boolean\n}\n\nconst TokenInput = React.forwardRef<\n  FocusRef,\n  TokenProps & TokenAdditionalProps & DelimiterActions\n>(\n  (\n    {\n      index,\n      text,\n      updateToken,\n      deleteToken,\n      parseToken,\n      containDelimiter,\n      hideRemoveButton\n    },\n    ref\n  ): React.ReactElement => {\n    const inputRef = useRef<HTMLInputElement | null>(null)\n    const spanRef = useRef<HTMLSpanElement | null>(null)\n    useImperativeHandle(ref, () => ({\n      focus: () => focus()\n    }))\n\n    function focus() {\n      inputRef.current!.focus()\n    }\n\n    function updateSpanText() {\n      spanRef.current!.innerText = inputRef.current!.value || '_'\n    }\n\n    function keyDown(event: React.KeyboardEvent) {\n      if (\n        event.key === 'Enter' ||\n        event.key === 'Tab' ||\n        containDelimiter(event.key)\n      ) {\n        view('self')\n        event.preventDefault()\n        event.stopPropagation()\n      } else if (event.key === 'Backspace' && !inputRef.current!.value) {\n        deleteToken([index])\n        event.preventDefault()\n      } else if (\n        event.key === 'ArrowLeft' &&\n        Utils.inputCaretStart(inputRef.current)\n      ) {\n        view('back')\n        event.preventDefault()\n      } else if (\n        event.key === 'ArrowRight' &&\n        Utils.inputCaretEnd(inputRef.current)\n      ) {\n        view('next')\n        event.preventDefault()\n      }\n    }\n\n    function view(focus: FocusMovement) {\n      applyToken(inputRef.current!.value, focus)\n    }\n\n    function applyToken(text: string, focus: FocusMovement) {\n      if (text) {\n        updateToken(index, parseToken(text), focus)\n      } else {\n        deleteToken([index])\n      }\n    }\n\n    function onPaste() {\n      setTimeout(() => {\n        view('self')\n      }, 0)\n    }\n\n    function onBlur(e: React.FocusEvent) {\n      const text: string = (e.nativeEvent.target as HTMLInputElement)!.value\n      setTimeout(() => {\n        applyToken(text, 'self')\n      }, 0)\n    }\n    return (\n      <span className={classes.token}>\n        <input\n          className={classes.input}\n          ref={inputRef}\n          onPaste={() => onPaste()}\n          onInput={(_) => updateSpanText()}\n          onKeyDown={(e) => keyDown(e)}\n          defaultValue={text}\n          onBlur={(e) => onBlur(e)}\n          type='text'\n        />\n        <span style={{ visibility: 'hidden' }} className={classes.tag}>\n          <span className={classes.value} ref={spanRef}>\n            {text}\n          </span>\n          {hideRemoveButton ? (\n            <span\n              onClick={() => deleteToken([index])}\n              className={classes.remove}\n            />\n          ) : null}\n        </span>\n      </span>\n    )\n  }\n)\n\nexport default TokenInput\n","import classes from \"./../styles.module.css\";\nimport React, { useEffect, useImperativeHandle, useRef } from \"react\";\n\nimport Utils from \"../Utils/Utils\";\nimport { FocusRef } from \"../TokenField/TokenField\";\nimport { DelimiterActions, FocusMovement, TokenProps } from \"../TokensReducer/TokensReducer\";\n\nexport interface NewTokenProps {\n  placeholder: string;\n  hideRemoveButton: boolean;\n}\n\nconst TokenNewInput = React.forwardRef<FocusRef,\n  NewTokenProps & TokenProps & DelimiterActions>(\n  (\n    {\n      state,\n      placeholder,\n      addToken,\n      hideRemoveButton,\n      deleteLast,\n      selectToken,\n      allTokenAreSelected,\n      containDelimiter,\n      parseToken,\n      focusLast,\n      deleteSelected\n    },\n    ref\n  ): React.ReactElement => {\n    const inputRef = useRef<HTMLInputElement | null>(null);\n    const spanRef = useRef<HTMLSpanElement | null>(null);\n    useEffect(() => {\n      updateSpanText();\n    });\n\n    function updateSpanText() {\n      spanRef.current!.innerText =\n        inputRef.current!.value || (state.tokens.length ? \"_\" : placeholder);\n    }\n\n    function keyDown(event: React.KeyboardEvent) {\n      if (event.key === \"Backspace\" || event.key === \"Delete\") {\n        if (\n          allTokenAreSelected() &&\n          Utils.inputTextFullSelection(inputRef.current)\n        ) {\n          deleteSelected();\n          inputRef.current!.value = \"\";\n        } else if (Utils.inputCaretStart(inputRef.current)) {\n          deleteLast();\n        }\n      } else if (event.key === \"Enter\" || containDelimiter(event.key)) {\n        viewMode(event);\n      } else if (\n        (event.key === \"ArrowLeft\" &&\n          Utils.inputCaretStart(inputRef.current)) ||\n        (event.shiftKey && event.key === \"Tab\")\n      ) {\n        focusLast();\n        event.preventDefault();\n      } else if (\n        !event.metaKey &&\n        !event.ctrlKey &&\n        Utils.inputTextFullSelection(inputRef.current)\n      ) {\n        selectToken([], false);\n      }\n    }\n\n    useImperativeHandle(ref, () => ({\n      focus: () => inputRef.current?.focus(),\n      value: () => inputRef.current?.value,\n      clear: () => (inputRef.current!.value = \"\"),\n      selectText: () => inputRef.current!.select()\n    }));\n\n    function viewMode(e: React.SyntheticEvent, focus: FocusMovement = \"self\") {\n      const text = inputRef.current!.value.trim();\n      inputRef.current!.value = \"\";\n      if (focus === \"self\" && !text) {\n        return;\n      }\n      addToken(parseToken(text), focus);\n      e.preventDefault();\n    }\n\n    function onPaste() {\n      setTimeout(() => {\n        addToken(parseToken(inputRef.current!.value), \"self\");\n        inputRef.current!.value = \"\";\n      }, 0);\n    }\n\n    return (\n      <span className={classes.token}>\n        <input\n          placeholder={state.tokens.length === 0 ? placeholder : \"\"}\n          className={classes.input}\n          ref={inputRef}\n          onInput={(_) => updateSpanText()}\n          onKeyDown={(e) => keyDown(e)}\n          onPaste={() => onPaste()}\n          type=\"text\"\n        />\n        <span style={{ visibility: \"hidden\" }} className={classes.tag}>\n          <span className={classes.value} ref={spanRef} />\n          {hideRemoveButton ? <span className={classes.remove} /> : null}\n        </span>\n      </span>\n    );\n  }\n);\n\nexport default TokenNewInput;\n","import { Token } from '../Token/Token'\nimport TokenInput from '../TokenInput/TokenInput'\nimport { TokenState, useTokens } from '../TokensReducer/TokensReducer'\nimport TokenNewInput from '../TokenNewInput/TokenNewInput'\nimport React, { useEffect, useRef } from 'react'\nimport classes from './../styles.module.css'\nimport {\n  getTokenFieldCSS,\n  TokenCSS,\n  TokenFieldCSS\n} from '../Styles/Token.style'\n\nexport interface FocusRef {\n  focus: () => void\n}\n\nexport interface NewInputRef extends FocusRef {\n  value: () => string\n  clear: () => void\n  selectText: () => void\n}\n\nexport type Details = { tokens: string[]; valid?: string[]; invalid?: string[] }\nconst TokenField = ({\n  tokens = [],\n  delimiters = ' ',\n  placeholder = '',\n  pattern = '',\n  readonly = false,\n  showRemoveButton = true,\n  tokenFieldCSS,\n  getTokenCSS,\n  onChange,\n  autoFocus = true\n}: {\n  tokens?: string[]\n  pattern?: string\n  placeholder?: string\n  delimiters?: string\n  readonly?: boolean\n  showRemoveButton?: boolean\n  tokenFieldCSS?: TokenFieldCSS\n  getTokenCSS?: (state: TokenState) => TokenCSS\n  onChange?: (details: Details) => void\n  autoFocus?: boolean\n}) => {\n  const tokenProps = useTokens(tokens, pattern, readonly, getTokenCSS)\n  const {\n    state,\n    isValid,\n    focusNew,\n    selectAll,\n    addToken,\n    deleteSelected,\n    getSelectedTokenText\n  } = tokenProps\n  const focusRefs = useRef<FocusRef[]>([])\n  const newTokenRef = useRef<NewInputRef | null>(null)\n  const tokenFieldRef = useRef<HTMLDivElement | null>(null)\n  useEffect(() => {\n    if (state.focusIndex !== -2) {\n      if (state.focusIndex !== -1) {\n        try {\n          focusRefs.current[state.focusIndex].focus()\n        } catch (e) {\n          console.error(e)\n        }\n      } else {\n        if (!readonly && (autoFocus || state.lastActionTime)) {\n          newTokenRef.current!.focus()\n        }\n      }\n    }\n  }, [state.lastActionTime, state.focusIndex])\n\n  useEffect(() => {\n    if (onChange) {\n      const details: Details = { tokens: state.tokens, valid: [], invalid: [] }\n      state.tokens.forEach((text) => {\n        const valid: boolean = isValid(text)\n        if (valid) {\n          details.valid!.push(text)\n        } else {\n          details.invalid!.push(text)\n        }\n      })\n\n      onChange(details)\n    }\n  }, [state.tokens])\n\n  function getTokenElement(token: string, index: number) {\n    return (\n      <Token\n        {...tokenProps}\n        text={token}\n        hideRemoveButton={showRemoveButton}\n        ref={(el) => addRef(el, index)}\n        selected={state.selectedIndexes.includes(index)}\n        index={index}\n        key={'token_' + index}\n      />\n    )\n  }\n\n  function containDelimiter(key: string): boolean {\n    return delimiters.includes(key)\n  }\n\n  function parseToken(token: string): string[] {\n    const newTokens: string[] = []\n    const rawText: string = token.trim()\n    const sep: string = `[ֿֿֿֿֿ\\\\n\\\\${delimiters}]+`\n    const tokensValue: string[] = rawText.split(new RegExp(sep))\n    for (const tokenValue of tokensValue) {\n      if (tokenValue.trim()) {\n        newTokens.push(tokenValue)\n      }\n    }\n    return newTokens\n  }\n\n  function addRef(ref: FocusRef | null, index: number) {\n    if (ref) {\n      focusRefs.current[index] = ref\n    }\n  }\n\n  function getTokenInputElement(token: string, index: number) {\n    return (\n      <TokenInput\n        {...tokenProps}\n        text={token}\n        ref={(el) => addRef(el, index)}\n        index={index}\n        hideRemoveButton={showRemoveButton}\n        containDelimiter={(key) => containDelimiter(key)}\n        parseToken={(token) => parseToken(token)}\n        selected={state.selectedIndexes.includes(index)}\n        key={'token_input_' + index}\n      />\n    )\n  }\n\n  function getTokenNewInputElement() {\n    if (!readonly) {\n      return (\n        <TokenNewInput\n          placeholder={placeholder}\n          hideRemoveButton={showRemoveButton}\n          ref={newTokenRef}\n          {...tokenProps}\n          containDelimiter={(key) => containDelimiter(key)}\n          parseToken={(token) => parseToken(token)}\n        />\n      )\n    } else {\n      return <span />\n    }\n  }\n\n  function onFocus(e: React.FocusEvent) {\n    if (e.target === tokenFieldRef.current) {\n      focusNew()\n    }\n  }\n\n  function onBlur(e: React.FocusEvent) {\n    const value = newTokenRef.current?.value()\n    const focusElement = e.relatedTarget?.closest(\n      `.${tokenFieldRef.current!.className}`\n    )\n    if (value && focusElement !== tokenFieldRef.current) {\n      newTokenRef.current!.clear()\n      addToken(parseToken(value), 'none')\n    }\n  }\n\n  function onKeyDown(event: React.KeyboardEvent) {\n    const cmdPressed: boolean = navigator.userAgent.indexOf('Mac')\n      ? event.metaKey\n      : event.ctrlKey\n    if (cmdPressed && event.nativeEvent.code === 'KeyA') {\n      selectAll()\n      newTokenRef.current!.selectText()\n      event.preventDefault()\n    } else if (cmdPressed && event.nativeEvent.code === 'KeyC') {\n      copyToken(\n        [...getSelectedTokenText(), newTokenRef.current?.value()].join(\n          delimiters[0]\n        )\n      )\n      focusNew()\n      event.preventDefault()\n    } else if (cmdPressed && event.key === 'KeyX') {\n      const value: string = newTokenRef.current?.value() || ''\n      newTokenRef.current!.clear()\n      copyToken([...getSelectedTokenText(), value].join(delimiters[0]))\n      deleteSelected()\n      event.preventDefault()\n    }\n  }\n\n  function copyToken(val: string) {\n    const selBox = document.createElement('textarea')\n    selBox.style.left = '0'\n    selBox.style.top = '0'\n    selBox.style.opacity = '0'\n    selBox.style.position = 'fixed'\n    selBox.value = val\n    document.body.appendChild(selBox)\n    selBox.focus()\n    selBox.select()\n    document.execCommand('copy')\n    document.body.removeChild(selBox)\n  }\n\n  return (\n    <div\n      className={classes.tokens}\n      style={getTokenFieldCSS(tokenFieldCSS)}\n      onKeyDown={(e) => onKeyDown(e)}\n      tabIndex={-1}\n      ref={tokenFieldRef}\n      onFocus={(e) => onFocus(e)}\n      onBlur={(e) => onBlur(e)}\n    >\n      {state.tokens.map((token, index) =>\n        index === state.editIndex && !readonly\n          ? getTokenInputElement(token, index)\n          : getTokenElement(token, index)\n      )}\n      {getTokenNewInputElement()}\n    </div>\n  )\n}\nexport default TokenField\n","import React from 'react'\n\nexport type TokenFieldCSS = Pick<\n  React.CSSProperties,\n  | 'border'\n  | 'resize'\n  | 'gap'\n  | 'height'\n  | 'background'\n  | 'padding'\n  | 'color'\n  | 'boxShadow'\n  | 'borderRadius'\n  | 'maxHeight'\n> | null\nexport const getTokenFieldCSS: (\n  cssStyle?: TokenFieldCSS\n) => React.CSSProperties = (cssStyle): React.CSSProperties => ({\n  resize: cssStyle?.resize || 'both',\n  height: cssStyle?.height || 'auto',\n  border: cssStyle?.border || '1px solid #ccc',\n  gap: cssStyle?.gap || '5px',\n  padding: cssStyle?.padding || '10px',\n  background: cssStyle?.background || '',\n  color: cssStyle?.color || '#333',\n  boxShadow: cssStyle?.boxShadow || 'none',\n  borderRadius: cssStyle?.borderRadius || 'unset',\n  maxHeight: cssStyle?.maxHeight || '200px'\n})\n\nexport type TokenCSS = Pick<\n  React.CSSProperties,\n  | 'border'\n  | 'padding'\n  | 'height'\n  | 'background'\n  | 'color'\n  | 'boxShadow'\n  | 'borderRadius'\n  | 'textDecoration'\n> | null\nexport const getTokenCSS: (css: TokenCSS) => TokenCSS | undefined = (\n  css: TokenCSS\n): TokenCSS => ({\n  padding: css?.padding || '10px',\n  height: css?.height || '100px',\n  border: css?.border || '1px solid #ccc',\n  background: css?.background || '',\n  color: css?.color || '#333',\n  boxShadow: css?.boxShadow || 'none',\n  borderRadius: css?.borderRadius || 'unset',\n  textDecoration: css?.textDecoration || 'none'\n})\n","import { TokenField } from 'react-tokenfield'\nimport 'react-tokenfield/dist/index.css'\nimport React, { useState } from 'react'\n\nconst App = () => {\n  const [tokens, setTokens] = useState<string[]>([\n    'shahar.levi@me.com',\n    'john.smith@google.com',\n    'invalid-email'\n  ])\n\n  const emailPattern: string =\n    '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$'\n\n  return (\n    <div\n      style={{\n        width: '400px',\n        padding: '10px',\n        margin: '0 auto'\n      }}\n    >\n      <TokenField\n        placeholder=\"Type an email\"\n        onChange={({ tokens }) => setTokens(tokens)}\n        pattern={emailPattern}\n        autoFocus={false}\n        showRemoveButton={false}\n        tokenFieldCSS={{\n          gap: '10px',\n          background: '#fff',\n          color: '#333',\n          borderRadius: '2px',\n          resize: 'none'\n        }}\n        tokens={tokens}\n      />\n      <h3>All Tokens</h3>\n      <ul>\n        {tokens.map(function (name, index) {\n          return <li key={index}>{name}</li>\n        })}\n      </ul>\n    </div>\n  )\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}